# Basic Block Profiler for gem5

This extension adds a Basic Block Profiler to gem5 that can track the execution of basic blocks in a program. It detects instructions that mark the beginning of a basic block by looking for the pattern "movq bbid#..." and records execution counts and times for each basic block.

## Building

1. Add the provided files to your gem5 source tree:
   - `gem5/src/cpu/probes/bb_profiler.hh`
   - `gem5/src/cpu/probes/bb_profiler.cc`
   - `gem5/src/cpu/probes/BBProfiler.py`

2. Update the `gem5/src/cpu/probes/SConscript` file to include the BBProfiler.

3. Build gem5 as usual:
   ```bash
   scons build/X86/gem5.opt -j$(nproc)
   ```

## Instrumenting Your Code

To use the BBProfiler, you need to instrument your code with basic block markers. This can be done using the provided LLVM pass in this repository.

1. Build the LLVM pass:
   ```bash
   mkdir -p build
   cd build
   cmake ..
   make
   ```

2. Use the `bb_map.sh` script to instrument your code:
   ```bash
   ./bb_map.sh your_source_file.cpp
   ```

   This will:
   - Compile your source file to LLVM IR
   - Apply the basic block instrumentation pass
   - Compile the instrumented IR to an executable
   - Analyze the executable to extract basic block mappings
   - Save the mappings to a CSV file

## Running with gem5

1. Use the provided example script to run your instrumented binary with gem5:
   ```bash
   ./build/X86/gem5.opt --debug-flags=BBProfiler x86-bb-profiler-example.py __test.exe
   ```

   You can also specify an output file for the profiling results:
   ```bash
   ./build/X86/gem5.opt --debug-flags=BBProfiler x86-bb-profiler-example.py __test.exe --output=my_profile.csv
   ```

   And pass arguments to your binary:
   ```bash
   ./build/X86/gem5.opt --debug-flags=BBProfiler x86-bb-profiler-example.py __test.exe --args="arg1 arg2"
   ```

2. The BBProfiler will generate a CSV file with the following columns:
   - Basic Block ID
   - Execution Count
   - Total Time (ticks)
   - Average Time (ticks)

## Example Output

```
Basic Block ID,Execution Count,Total Time (ticks),Average Time (ticks)
_Z9fibonaccii#entry,10,5000,500.00
_Z9fibonaccii#if.then,5,2000,400.00
_Z9fibonaccii#if.end,10,8000,800.00
_Z9fibonaccii#return,10,1000,100.00
main#entry,1,500,500.00
```

## How It Works

1. The BBProfiler is a ProbeListener that attaches to the CPU's CommittedInst probe point.
2. For each committed instruction, it checks if the instruction is a basic block marker by looking for the pattern "movq bbid#..." in the disassembly.
3. When it finds a basic block marker, it extracts the basic block ID and records the execution count and time.
4. At the end of the simulation, it writes the results to a CSV file.

## Implementation Details

The BBProfiler uses the following components:

1. **ProbeListenerObject**: Base class for objects that listen to probe points.
2. **ProbeListenerArg**: Template class that handles the notification of probe events.
3. **CommittedInst probe point**: Notifies the BBProfiler when an instruction is committed.

The BBProfiler receives a pair containing the static instruction and the PC state for each committed instruction. It then checks if the instruction is a basic block marker by examining its disassembly.

## Debugging

You can enable debug output by adding the `--debug-flags=BBProfiler` option to your gem5 command line. This will show detailed information about each basic block marker found during execution.

## Limitations

- The current implementation only works with x86 binaries that have been instrumented with the provided LLVM pass.
- The regex pattern for detecting basic block markers may need to be adjusted based on the actual assembly generated by the LLVM pass.
- The profiler only tracks basic blocks that have been instrumented with the LLVM pass. 